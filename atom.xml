<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NexT</title>
  
  
  <link href="https://theme-next.js.org/atom.xml" rel="self"/>
  
  <link href="https://theme-next.js.org/"/>
  <updated>2021-10-10T09:27:59.990Z</updated>
  <id>https://theme-next.js.org/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://theme-next.js.org/%E5%89%91%E8%B5%B0%E5%81%8F%E9%94%8B/"/>
    <id>https://theme-next.js.org/%E5%89%91%E8%B5%B0%E5%81%8F%E9%94%8B/</id>
    <published>2021-10-18T09:44:51.286Z</published>
    <updated>2021-10-10T09:27:59.990Z</updated>
    
    <content type="html"><![CDATA[<p>剑走偏锋</p><p>王道操作系统+背面试题</p><p>java+剑指offer题目</p><p>前端学到react,跨过vue,</p><p>客户端尝试下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;剑走偏锋&lt;/p&gt;
&lt;p&gt;王道操作系统+背面试题&lt;/p&gt;
&lt;p&gt;java+剑指offer题目&lt;/p&gt;
&lt;p&gt;前端学到react,跨过vue,&lt;/p&gt;
&lt;p&gt;客户端尝试下&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://theme-next.js.org/java%E6%A0%B8%E5%BF%83%E5%88%9D%E7%BA%A7%20p34/"/>
    <id>https://theme-next.js.org/java%E6%A0%B8%E5%BF%83%E5%88%9D%E7%BA%A7%20p34/</id>
    <published>2021-10-18T09:44:51.197Z</published>
    <updated>2021-10-09T08:11:01.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java核心初级-p34"><a href="#java核心初级-p34" class="headerlink" title="java核心初级 p34"></a>java核心初级 p34</h1><p><strong>try、catch、finally用法总结:</strong></p><p>　　1、不管有没有异常，finally中的代码都会执行</p><p>　　2、当try、catch中有return时，finally中的代码依然会继续执行</p><p>　　3、finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</p><p>　　4、finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</p><p>重写方法时，子类方法所抛出的异常不能超过父类方法的异常范围</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java核心初级-p34&quot;&gt;&lt;a href=&quot;#java核心初级-p34&quot; class=&quot;headerlink&quot; title=&quot;java核心初级 p34&quot;&gt;&lt;/a&gt;java核心初级 p34&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;try、catch、finally用法总结:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://theme-next.js.org/1.%E6%88%91%E7%8E%B0%E5%9C%A8%E6%B3%A8%E9%87%8D%E5%AE%8F%E8%A7%82%E5%8D%B4%E4%B8%8D%E6%B3%A8%E9%87%8D%E5%BE%AE%E8%A7%82%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E5%BE%88%E9%94%99%E8%AF%AF%E7%9A%84%E3%80%82/"/>
    <id>https://theme-next.js.org/1.%E6%88%91%E7%8E%B0%E5%9C%A8%E6%B3%A8%E9%87%8D%E5%AE%8F%E8%A7%82%E5%8D%B4%E4%B8%8D%E6%B3%A8%E9%87%8D%E5%BE%AE%E8%A7%82%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E5%BE%88%E9%94%99%E8%AF%AF%E7%9A%84%E3%80%82/</id>
    <published>2021-09-25T03:25:00.995Z</published>
    <updated>2021-09-25T03:25:01.177Z</updated>
    
    <content type="html"><![CDATA[<p>1.我现在注重宏观却不注重微观，其实是很错误的。</p><p>2.如果只有经历才能成长，那人生也太累了呢，为什么要背负无数的风尘？所以说有些事情没有必要经历，看着别人踩坑就好，但要对踩坑者的勇气报以钦佩。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.我现在注重宏观却不注重微观，其实是很错误的。&lt;/p&gt;
&lt;p&gt;2.如果只有经历才能成长，那人生也太累了呢，为什么要背负无数的风尘？所以说有些事情没有必要经历，看着别人踩坑就好，但要对踩坑者的勇气报以钦佩。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://theme-next.js.org/1.%E4%B8%8D%E6%98%AF%E8%92%99%E5%8F%A4%E5%85%A5%E4%BE%B5%EF%BC%8C%E8%A5%BF%E6%96%B9%E6%9C%AA%E5%BF%85%E4%BC%9A%E5%8F%91%E5%B1%95%E5%87%BA%E7%A7%91%E5%AD%A6%EF%BC%8C%E5%8F%8D%E8%80%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E9%98%BF%E6%8B%89%E4%BC%AF%E4%B8%96%E7%95%8C%E5%85%88%E5%87%BA/"/>
    <id>https://theme-next.js.org/1.%E4%B8%8D%E6%98%AF%E8%92%99%E5%8F%A4%E5%85%A5%E4%BE%B5%EF%BC%8C%E8%A5%BF%E6%96%B9%E6%9C%AA%E5%BF%85%E4%BC%9A%E5%8F%91%E5%B1%95%E5%87%BA%E7%A7%91%E5%AD%A6%EF%BC%8C%E5%8F%8D%E8%80%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E9%98%BF%E6%8B%89%E4%BC%AF%E4%B8%96%E7%95%8C%E5%85%88%E5%87%BA/</id>
    <published>2021-08-24T12:43:09.417Z</published>
    <updated>2021-08-24T12:44:21.325Z</updated>
    
    <content type="html"><![CDATA[<p>1.不是蒙古入侵，西方未必会发展出科学，反而可能是阿拉伯世界先出</p><p>2.日本17世纪开始逐渐社会发展程度超过中国，和算中有些关于微积分的成果</p><p>同时期中国并没有发展出类似的成果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.不是蒙古入侵，西方未必会发展出科学，反而可能是阿拉伯世界先出&lt;/p&gt;
&lt;p&gt;2.日本17世纪开始逐渐社会发展程度超过中国，和算中有些关于微积分的成果&lt;/p&gt;
&lt;p&gt;同时期中国并没有发展出类似的成果&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://theme-next.js.org/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81key/"/>
    <id>https://theme-next.js.org/1.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81key/</id>
    <published>2021-08-03T08:41:33.536Z</published>
    <updated>2021-08-04T01:19:51.354Z</updated>
    
    <content type="html"><![CDATA[<p>1.为什么需要key</p><p>增加渲染效率</p><p>没key<li>的添加导致</p><p>提高渲染效率</p><p>React的key不要用index</p><p>不推荐用index</p><p>index对应数据重排会导致重新渲染</p><p>正常的列表数据index做key影响不大</p><p>index会导致重新渲染</p><p>用的多了会导致变慢</p><p>为什么setState是一个异步过程</p><p>内部一致性</p><p>state同步 props异步会导致很多问题</p><p>性能优化</p><p>批量处理的过程，</p><p>不断改方案</p><p>改成d方案</p><p>什么是Hooks？</p><p>functional conponent 没有state 没有生命周期</p><p>有了Hooks</p><p>functional component+hooks =class component</p><p>useState()</p><p>useReducer()</p><p>useEffect()</p><p>useContext()</p><p>代码质量-可复用性</p><p>mixin-&gt;Hoc-&gt;Render Props-&gt;Hooks</p><p>mixin方案出现源自一种oop直觉</p><p>Mixin的缺陷</p><p>隐式依赖</p><p>可能产生冲突</p><p>倾向于增加更多状态</p><p>计时器</p><p>细粒度代码复用不应该和组件复用捆绑</p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803161349337.png" alt="image-20210803161349337" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803161408482.png" alt="image-20210803161408482" loading="lazy"><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803161550370.png" alt="image-20210803161550370" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803161644695.png" alt="image-20210803161644695" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803163256637.png" alt="image-20210803163256637" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803163351175.png" alt="image-20210803163351175" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803163523773.png" alt="image-20210803163523773" loading="lazy"></p><p>问个code答不上来，面试官会觉得水</p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803163720413.png" alt="image-20210803163720413" loading="lazy"></p><p>建立可复用的tcp连接</p><p>，这个主要为了兼容老版本的tc<img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803163924624.png" alt="image-20210803163924624" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803164443837.png" alt="image-20210803164443837" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803164122390.png" alt="image-20210803164122390" loading="lazy"></p><p>Get和Post的区别</p><p>Option put</p><p>通常一起比较</p><p>get去拿</p><p>一般服务器获取资源数据</p><p>post一般向服务器提交资源</p><p>get请求能做的事情post也能做</p><p>get方法安全且幂等的</p><p>post新增</p><p>提交多次有多个资源不是幂等的</p><p>get一些查询条件</p><p>服务器不规范也是能处理</p><p>get可以被cache的</p><p>post很难被缓存</p><p>HTTp1.1优缺点</p><ol><li><p>简单灵活 </p></li><li><p>跨平台 </p></li><li><p>无状态</p></li></ol><p>服务器不需要额外资源记录状态信息</p><p>其实坏处是没有记忆能力，关联性的操作很麻烦</p><p>cookie保证不用每一步验证</p><p>明文传输</p><ul><li>可以方便的阅读</li><li>信息裸奔</li><li>可能被篡改</li></ul><p>安全性</p><p>https多了一层</p><p>tls层secure层</p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210803214233343.png" alt="image-20210803214233343" loading="lazy"></p><p>冒充风险</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.为什么需要key&lt;/p&gt;
&lt;p&gt;增加渲染效率&lt;/p&gt;
&lt;p&gt;没key&lt;li&gt;的添加导致&lt;/p&gt;
&lt;p&gt;提高渲染效率&lt;/p&gt;
&lt;p&gt;React的key不要用index&lt;/p&gt;
&lt;p&gt;不推荐用index&lt;/p&gt;
&lt;p&gt;index对应数据重排会导致重新渲染&lt;/p&gt;
&lt;p&gt;正常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Number和String方法</title>
    <link href="https://theme-next.js.org/Number%E5%92%8CString%E6%96%B9%E6%B3%95/"/>
    <id>https://theme-next.js.org/Number%E5%92%8CString%E6%96%B9%E6%B3%95/</id>
    <published>2021-07-30T16:31:17.000Z</published>
    <updated>2021-07-30T09:02:00.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Number和String方法-背后的转换原则"><a href="#Number和String方法-背后的转换原则" class="headerlink" title="Number和String方法--背后的转换原则"></a>Number和String方法--背后的转换原则</h1><h2 id="Number方法"><a href="#Number方法" class="headerlink" title="Number方法"></a>Number方法</h2><ol><li><p>先调用对象自身的valueOf方法，若返回原始类型的值，则使用Number方法，放弃后续的步骤</p></li><li><p>若valueOf方法返回对象，则改用ToString方法，若返回原始类型的值，则使用Number方法，不再进行后续步骤</p></li><li><p>如果toString方法返回的是对象，就报错</p></li></ol><h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h2><ol><li><p>先调用对象的toString方法，若返回原始类型的值，则使用String方法，不再进行后续步骤</p></li><li><p>如果toString方法返回对象，使用valueOf方法，若返回原始类型的值，则使用String方法，不再进行后续步骤</p></li><li><p>如果valueOf方法返回对象，则报错</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Number和String方法-背后的转换原则&quot;&gt;&lt;a href=&quot;#Number和String方法-背后的转换原则&quot; class=&quot;headerlink&quot; title=&quot;Number和String方法--背后的转换原则&quot;&gt;&lt;/a&gt;Number和String方法-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>fix</title>
    <link href="https://theme-next.js.org/fix/"/>
    <id>https://theme-next.js.org/fix/</id>
    <published>2021-07-22T13:46:52.000Z</published>
    <updated>2021-07-22T05:46:52.169Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>html00</title>
    <link href="https://theme-next.js.org/html00/"/>
    <id>https://theme-next.js.org/html00/</id>
    <published>2021-07-20T12:46:07.000Z</published>
    <updated>2021-07-20T09:43:32.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屮"><a href="#屮" class="headerlink" title="屮"></a>屮</h1><p>html不管样式<br>css管样式<br>不能把视频当电视剧看多查文档<br>navigation-<nav><br>alternative-alt<br>不要一直用<div><br><span> <DIV>没有意义的标签<br>中文英文关系</p><h2 id="和区别"><a href="#和区别" class="headerlink" title="和区别"></a><button>和<input type="button">区别</h2><p>button不是一个空元素<br><input type="button">不能有自己元素 </p><p>空元素<meta> <link> <hr><br><col><colgroup></p><p>html5不推荐input写成自闭合的</p><div>就是写到<head></head>里面也会被浏览器纠错放到<body></body>里base title meta link script noscript可以出现在head元素内<p><noscript> 如果用户浏览器不支持script 则展示noscript中的内容</p><p>   iframe可以拥有一个name，a标签的target可以通过name指向这个iframe</p><p>现代前端开发中iframe很少用</p><p>iframe用于在当前页面里嵌入一个页面</p><meta charset="utf-8">* html5更新后<meta http-equip="content-type" content="text\html" charset ="utf-8"><ul><li><p>http等价物</p></li><li><p>body 默认margin:8px</p></li><li><p>span，image默认display inline</p></li><li><p>div，ul，h1默认display block </p></li></ul><p>img可替换元素=》替换为图片，宽高待图片下载后产生</p><p>img input video</p><ul><li>外观渲染独立于css</li></ul><p>css优先级比属性要高，属性不是内联样式</p><p>html全称?</p><ul><li>Hyper Text Makeup Language</li></ul><p>Who is making  the Web standards?</p><ul><li>The World Wide Web Consortium(w3c)</li></ul><p>What is the correct Html element for inserting a line break</p><br><p>html早期自带css一些属性</p><p>李爵士发明html时候没有css</p><p>bgcolor背景色</p><p>What is the correct html for adding a background color?</p><body style="background-color:yellow;"><p>Choose the correct Html element to define important text?</p><strong><p>Choose the correct html element to define emphasizzed text</p><em><p>em语气重</p><p>strong地位重</p><p>How can you open a link in anew tab/browser window ?</p><a href="url" target="_blank"><p>Which of these elements are all <table> elements?(d)</p><p>a.<thead>，<body>,<tr></p><p>b.<table>,<tr>,<tt></p><p>c.<table>,<head>,<tfoot></p><p>d.<table><tr><td></p><p>inline 内联元素<br>Inline elements are normally displayed without starting a new line</p><p>How can you make a numbered list?<br>ans:<ol></p><p>How can you make a bulleted list?</p><ul><ol><list><dl>ans:<ul>What is the correct Html for making a checkbox?(a)a.<input type="checkbox">b.<input type="check">c.<checkbox>d.<check><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210720153829499.png" alt="image-20210720153829499" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210720153856363.png" alt="image-20210720153856363" loading="lazy"></p><p>What is the correct html for making a text area?</p><textarea>What is the correct html for inserting a background image<body style ="background-image:url(background.jpg)"In html you can embed svg elements directly into an html page(true)contenteditable="true"The html global attribute "contenteditable" is used to Specify whether the content of an element should be eaditable or notIn html onblur and onfocus is 事件event attributessvg是xml格式的<canvas>元素用来draw graphicsIn html,which attribute is used to specify that an input field must be filled out?ans:requiredwhich input type defines a slider control?ans:rangewhich html element is used to display a scalar measurement within a range<meter>非·<measure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;屮&quot;&gt;&lt;a href=&quot;#屮&quot; class=&quot;headerlink&quot; title=&quot;屮&quot;&gt;&lt;/a&gt;屮&lt;/h1&gt;&lt;p&gt;html不管样式&lt;br&gt;css管样式&lt;br&gt;不能把视频当电视剧看多查文档&lt;br&gt;navigation-&lt;nav&gt;&lt;br&gt;alternative-al</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>凝死，报恩</title>
    <link href="https://theme-next.js.org/%E5%87%9D%E6%AD%BB%EF%BC%8C%E6%8A%A5%E6%81%A9/"/>
    <id>https://theme-next.js.org/%E5%87%9D%E6%AD%BB%EF%BC%8C%E6%8A%A5%E6%81%A9/</id>
    <published>2021-07-19T13:37:38.000Z</published>
    <updated>2021-07-19T05:39:08.268Z</updated>
    
    <content type="html"><![CDATA[<p>望着祖母离去的眼，凝视祖母的死亡，我竟不带一丝一毫的同情。</p><p>也许是出于对她行为的嫉妒，祖母并不心疼我，虽然我是正孙可她却最喜欢外孙，我甚至觉得，她生出我的父亲，是一个错误。</p><p>说到我的高中时期。</p><p>父亲一直认定我是追女生j开始不好好学习的，对我的态度也日趋恶劣。</p><p>其实大概是我被人孤立排挤了。</p><p>父亲是极矛盾的人，本身自己就是极平凡的人，我中学时却要我去学习乔布斯呢，我当时没什么社会经验，学乔布斯问女生是不是处，学乔布斯骂人无视讨厌的人，骂了我讨厌的但喜欢我的姑娘，将她的事迹给别人讲，然后那人竟传的整个班上我是屌丝意淫。全班同学以我为逗乐，拍屌拔裤子什么的就不说了，被全班所孤立，极为痛苦，我当时的精神都不愿意再拿来说了。</p><p>父亲说：”谁欺负你了给我说啊。“可当我被全班孤立之时，他只会说我不会打架，不会相处等等。并不愿意听我细细去讲，一度还以为我怀了春”</p><p>从那时起，我对父亲变得愤懑起来，他渐渐对我的不满也与日俱增。</p><p>听到了沉重的步伐声，我急忙藏起我的语录本。父亲要是看到了我写的那些“神神叨叨”的话，定会撕了我的小本，扇我巴掌，吼叫到：“你他妈的有没有出息，人家xx家的孩子都能学到两三点，你为什么没能学到那么晚？写的是些什么垃圾玩意儿？”</p><p>可是掏出练习册，册子是空的。</p><p>’麻烦大了。。。‘</p><p>父亲翻了下我的练习册，立马删了我一巴掌。</p><p>我又气又愤：“还让不让人过了？”</p><p>“你自己不锻炼，没有体力，我听你们班主任说人家xx的孩子为了高考都拼了，一天睡四个小时。我是为了你好，现在不努力，以后你哭去吧？”父亲丝毫对我没有同情，只是把心中的不满引爆到我的身上。</p><p>那会儿确实是困了，想睡觉。可父亲揪起我的头发，把我往墙边撞去。我无力反抗，像个被警察殴打的犯人一样狼狈，好像是犯下了什么罪行，接受着“正义”的拷打。</p><p>到省城上学，是我的希望，但是父亲不让我一人去，“不放心你！”，原话是说得好听，托关系到了省城，他找的人因为站错队丢了职务，他自然没有被安排职位，心情不好，没有人去开涮，原来这个垃圾桶是我妈妈，现在呢我就成了他的垃圾桶，他的发泄口。</p><p>“哎。。。”我真是倒霉，白白受到这种对待，还不能反抗。</p><p> “你看看人家怎么学习的，你不学习到凌晨怎么能行？高中拼一拼就为了你的将来，现在不拼更待何时？”这种话从家里到学校，一直在提，一直在说，教员和家长的话里，好像谁睡得少就是一种荣耀似的，人不睡觉怎么得行？</p><p>   但是，我，毕竟太过懦弱，总要在人前装出一种和善的样子，只能在背后哀叹自己的无能，慢慢让自己也接受了这种成功学似的话术。因为这种生活方式太过疲惫，时不时一个人自己与自己相慰籍，莫名的泪从眼中流出，经过脸颊流下，但又不好意思让人知道我的软弱。</p><p>   成功人士可能真睡四个小时吗？</p><p>   就算有，也是极为偶然有一天睡得少些吧。</p><p>   在“暴君”的荒谬统治下，长达数月四五小时的睡眠让我的体型不在均匀，有点弯腰驼背的样子，眼前是重重的眼袋。。。皮肤也不在光鲜，人也越来越毛躁，越来越听不进去课了，家里晚上不让我睡，我就白天在课堂睡。老师要就我起来，我就站着睡，没有睡眠的我像一具活尸，记忆力不断的衰退。班主任和家长天天喂我成功学鸡汤。</p><p>父亲只会说，是你不够努力。</p><p>老师也是这么说。</p><p>我不但憎恶起了父亲，也同样憎恶起了老师，渐渐的与他们对抗。</p><p>”鳅老师指着我眼睛，说我如果是他的孩子要狠狠扇我。“这是我对年级主任说的话，作为对她的恩情的奉还。</p><p>年纪主任将她批评了一番，鳅老师之后看我双眼带着憎恶，没错，这就是当时的我想要的，我并不想让别人喜欢我，只想自绝于社会，也许有人看来我是惯坏的怪胎，可我的伤痛他们想必也没有耐心倾听。</p><p>想必有一天，当我的父亲离世之日，我也许会装出哭腔，但内心毫无怜悯吧，毕竟我的领主的领主不是我的领主，我的家长的家长不是我的家长。</p><p>我仍旧要在家长的面前装弱，好像自己是个什么都不懂的人，待他的支配罢，</p><p>日夜的折磨下，我有那么一两刻想过自绝于人世，或是将父亲这只肥猪用剪刀捅向心窝。矛盾激化至此，也是难收回了呢。</p><p>我觉得还是要积聚力量吧，毕竟15-16岁的孩子和正当壮年的人打架还是要吃亏的吧。</p><p>所幸没有做出那样的决定吧，这是我对死亡的凝视。</p><p>我本来是想和父亲断绝关系的，可是呢，疫情在家的日子里却又和他们走得更近了，我的心也是软呢，虽然他喝酒后暴躁，虽然他希望去控制我，但我也有好处-可以利用他的控制欲帮我做一些事情：“比如让他掏钱。寄生于人虽然没有任何地位，但是总好过饿死，也许我本不想出生，可为何他们生了我呢。</p><p>毕竟啊这些中老年男性，就是待死之人，而我父亲这种呢，外面混的不顺心时，特别强调自己在家中的权威性，因为养老要靠子女吧，所以要建立权威性和让孩子感恩。</p><p>我的内心只有感恩，这感恩呢，是五味杂陈的感恩。</p><p>以后呢，也许是父亲凝视我的死亡呢，也许是我凝视父亲的死亡呢，变数太多，不好说清。</p><p>我当初是希望他们白发人快点送我黑发人走，可现在感觉对生有了一点迷恋，毕竟我还希望能留给后人一些东西，无论是代码还是文章，或是社会事务的贡献，虽然自己的心灵受了痛苦，但我好像对人类弥留了些爱恋，肯定是要报恩的。</p><p>写于2021.7.18</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;望着祖母离去的眼，凝视祖母的死亡，我竟不带一丝一毫的同情。&lt;/p&gt;
&lt;p&gt;也许是出于对她行为的嫉妒，祖母并不心疼我，虽然我是正孙可她却最喜欢外孙，我甚至觉得，她生出我的父亲，是一个错误。&lt;/p&gt;
&lt;p&gt;说到我的高中时期。&lt;/p&gt;
&lt;p&gt;父亲一直认定我是追女生j开始不好好学习</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jsexample01</title>
    <link href="https://theme-next.js.org/jsexample01/"/>
    <id>https://theme-next.js.org/jsexample01/</id>
    <published>2021-07-16T16:02:55.000Z</published>
    <updated>2021-07-16T08:24:54.647Z</updated>
    
    <content type="html"><![CDATA[<ol><li>函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话<br>说，一个函数可能会有多个名字，如下面的例子所示。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>以上代码首先定义了一个名为 sum() 的函数，用于求两个值的和。然后，又声明了变量 anotherSum ，<br>并将其设置为与 sum 相等（将 sum 的值赋给 anotherSum ）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时， anotherSum 和 sum 就都指向了同一个函数，因此 anotherSum() 也<br>可以被调用并返回结果。即使将 sum 设置为 null ，让它与函数“断绝关系”，但仍然可以正常调用<br>anotherSum() </p><ol start="2"><li>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。请看下面的例子。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FunctionDeclarationExample01.htm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升<br>（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声<br>明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；而且，由于第一<br>行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。<br>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话&lt;br&gt;说，一个函数可能会有多个名字，如下面的例子所示。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>jsexample00-date</title>
    <link href="https://theme-next.js.org/jsexample/"/>
    <id>https://theme-next.js.org/jsexample/</id>
    <published>2021-07-16T15:44:05.000Z</published>
    <updated>2021-07-16T08:02:26.208Z</updated>
    
    <content type="html"><![CDATA[<p>// GMT 时间 2000 年 1 月 1 日午夜零时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>// GMT 时间 2005 年 5 月 5 日下午 5:55:55</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><p>​                                                                                                        <code>DateTypeUTCExample01.htm</code><br>这个例子创建了两个日期对象。第一个对象表示 GMT 时间 2000 年 1 月 1 日午夜零时，传入的值一<br>个是表示年份的 2000，一个是表示月份的 0（即一月份）。因为其他参数是自动填充的（即月中的天数为 1，其他所有参数均为 0），所以结果就是该月第一天的午夜零时。第二个对象表示 GMT 时间 2005年 5 月 5 日下午 5:55:55，即使日期和时间中只包含 5，也需要传入不一样的参数：月份必须是 4（因为月份是基于 0 的）、小时必须设置为 17（因为小时以 0 到 23 表示），剩下的参数就很直观了。</p><p>因此，如果第一个参数是数值， Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，<br>以此类推。据此，可以将前面的例子重写如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地时间 2000 年 1 月 1 日午夜零时</span></span><br><span class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 本地时间 2005 年 5 月 5 日下午 5:55:55</span></span><br><span class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br><span class="line"><span class="comment">// DateTypeConstructorExample01.htm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时<br>区创建的</p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210716155703497.png" alt="image-20210716155703497" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210716155745891.png" alt="image-20210716155745891" loading="lazy"></p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210716155757315.png" alt="image-20210716155757315" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;// GMT 时间 2000 年 1 月 1 日午夜零时&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;ke</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js00</title>
    <link href="https://theme-next.js.org/js00/"/>
    <id>https://theme-next.js.org/js00/</id>
    <published>2021-07-16T15:04:30.000Z</published>
    <updated>2021-07-16T07:06:16.032Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 有5 种简单数据类型（也称为基本数据类型）：</p><ul><li><p>5 种简单数据类型：Null 、Boolean 、 Number、String、Undefined  。</p></li><li><p>还有1种复杂数据类型—— Object。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECMAScript 有5 种简单数据类型（也称为基本数据类型）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;5 种简单数据类型：Null 、Boolean 、 Number、String、Undefined  。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还有1种复杂数据类型—— Obje</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js要点-defer_async</title>
    <link href="https://theme-next.js.org/defer-async/"/>
    <id>https://theme-next.js.org/defer-async/</id>
    <published>2021-07-16T14:54:22.000Z</published>
    <updated>2021-07-16T06:56:13.962Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</p></li><li><p>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚<br>本按照它们在页面中出现的顺序执行。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚&lt;br&gt;本按照它们在页面中出现的顺序</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学一行爱一行·我看大可不必</title>
    <link href="https://theme-next.js.org/%E5%AD%A6%E4%B8%80%E8%A1%8C%E7%88%B1%E4%B8%80%E8%A1%8C%C2%B7%E6%88%91%E7%9C%8B%E5%A4%A7%E5%8F%AF%E4%B8%8D%E5%BF%85/"/>
    <id>https://theme-next.js.org/%E5%AD%A6%E4%B8%80%E8%A1%8C%E7%88%B1%E4%B8%80%E8%A1%8C%C2%B7%E6%88%91%E7%9C%8B%E5%A4%A7%E5%8F%AF%E4%B8%8D%E5%BF%85/</id>
    <published>2021-07-16T14:38:42.000Z</published>
    <updated>2021-07-16T06:47:55.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经常有人说，学一行爱一行，要找到心之所爱"><a href="#经常有人说，学一行爱一行，要找到心之所爱" class="headerlink" title="经常有人说，学一行爱一行，要找到心之所爱"></a>经常有人说，学一行爱一行，要找到心之所爱</h2><p>可我却要质疑，如果非要等到你对某样事物有兴趣了才去做，会不会晚了些呢，社会竞争激烈，会不会在犹豫间，就失去了机会呢。人生，怎么会是仅仅去喜欢就够了的呢，就像你爱一个女孩死心踏地去追，还会不会落一场空呢；如果佛系一些，女孩又会白白送来吗；建议你还是先花费些精力去做吧，就像我的某朋友，撒大网才能钓大鱼，韭菜不要有过多的感受，现在开始结网，以后说不定收获累累呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经常有人说，学一行爱一行，要找到心之所爱&quot;&gt;&lt;a href=&quot;#经常有人说，学一行爱一行，要找到心之所爱&quot; class=&quot;headerlink&quot; title=&quot;经常有人说，学一行爱一行，要找到心之所爱&quot;&gt;&lt;/a&gt;经常有人说，学一行爱一行，要找到心之所爱&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java核心04-类转型</title>
    <link href="https://theme-next.js.org/%E7%B1%BB%E8%BD%AC%E5%9E%8B/"/>
    <id>https://theme-next.js.org/%E7%B1%BB%E8%BD%AC%E5%9E%8B/</id>
    <published>2021-06-01T09:45:34.000Z</published>
    <updated>2021-07-15T13:40:23.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类转型"><a href="#类转型" class="headerlink" title="类转型"></a>类转型</h1><h2 id="类转型1"><a href="#类转型1" class="headerlink" title="类转型1"></a>类转型1</h2><ul><li><p>变量支持相互转化，比如int a=(int)3.5;</p></li><li><p>变量可以相互转型，但是只限制于有继承关系的类。</p><ul><li>子类可以转换为父类，而父类不可以转换为子类</li><li>子类可以继承父类所有的财产，子类可以变成父类，从大变小，即向上转型</li><li>而父类直接变成子类（从小变大，即向下转型）则不允许</li></ul></li><li><p>父类转为子类有一种情况例外</p><pre><code>* 就是这个父类本身就是从子类转化的</code></pre></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I can eat more&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ploygh</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">Man obj1=<span class="keyword">new</span> Man();</span><br><span class="line">        obj1.eat();</span><br><span class="line">        Human obj2=(Human) obj2;</span><br><span class="line">        obj2.eat();</span><br><span class="line">        Man obj3=(Man) obj2;</span><br><span class="line">        obj3.eat();</span><br><span class="line">        <span class="comment">//obj1==obj2;//true</span></span><br><span class="line">        <span class="comment">//obj2==obj3;//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的作用</p><ul><li>以统一的接口来操纵某一类中不同的对象的动态行为</li><li>对象之间的解耦</li></ul><h2 id="契约设计"><a href="#契约设计" class="headerlink" title="契约设计"></a>契约设计</h2><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210501231741365.png" alt="image-20210501231741365" loading="lazy"></p><p>契约：规定规范了对象应该包含的行为方法</p><p>接口定义了方法的名称参数和返回值</p><p>基于接口，利用转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦</p><p><img src="C:\Users\zr199\AppData\Roaming\Typora\typora-user-images\image-20210501230936328.png" alt="image-20210501230936328" loading="lazy"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java支持子类转父类，但不支持父类转子类，除非父类对象最早就是子类转型父类而来</p><p>多态：子类转型为父类后，调用普通方法，依旧是子类本身的方法</p><p>契约设计：类不会直接调用另外一个类，而是采用接口形式，外部可以空投这个接口下的任意子类对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类转型&quot;&gt;&lt;a href=&quot;#类转型&quot; class=&quot;headerlink&quot; title=&quot;类转型&quot;&gt;&lt;/a&gt;类转型&lt;/h1&gt;&lt;h2 id=&quot;类转型1&quot;&gt;&lt;a href=&quot;#类转型1&quot; class=&quot;headerlink&quot; title=&quot;类转型1&quot;&gt;&lt;/a&gt;类转型</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java核心02-继承</title>
    <link href="https://theme-next.js.org/%E7%BB%A7%E6%89%BF/"/>
    <id>https://theme-next.js.org/%E7%BB%A7%E6%89%BF/</id>
    <published>2021-05-08T15:12:26.000Z</published>
    <updated>2021-07-15T13:42:06.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1-1继承"><a href="#6-1-1继承" class="headerlink" title="6.1.1继承"></a>6.1.1继承</h1><p>先看一个例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        Son s=<span class="keyword">new</span> Son();</span><br><span class="line">        S.f1();</span><br><span class="line">        <span class="comment">//Son中没有f1方法的定义，根据父类继承的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>面向过程编程语言没有继承，导致出现很多类型重复定义</p></li><li><p>物以类聚，世间万物皆对象，对象也可以划分为若干类别</p></li><li><p>类别内的对象属性和方法都有一定的共同点</p></li><li><p>将共同点提取出来，形成父类（或者叫基类，超类）</p><p>Parent class/Base class/Super class</p></li><li><p>而其他类则自动为子类派生类</p><p>Child class/Derived class</p></li></ul><p>从很多个对象中提取出共性，形成父类，其他类继承父类成为子类，也具有这些共性</p><ul><li><p>Man extends human 表示Man继承于humna</p></li><li><p>Human是父类，Man是子类</p></li><li><p>子类继承父类中所有的属性和方法（但不能直接访问private成员</p></li><li><p>根据信息隐藏原则：子类会继承父类中所有的方法。可以直接使用。</p></li><li><p>子类也会继承父类的父类的所有属性和方法（但不嫩更直接访问private成员)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="comment">//private int num=20;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Derived foo =<span class="keyword">new</span> Derived();</span><br><span class="line">        System.out.println(foo.getNUm());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​    输出结果为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>//子类可以通过调用父类的方法来访问父类的私有的成员属性</p><h2 id="方法优先级"><a href="#方法优先级" class="headerlink" title="方法优先级"></a>方法优先级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Derived foo =<span class="keyword">new</span> Derived();</span><br><span class="line">        System.out.println(foo.getNUm());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这说明了在同样方法名和参数情况下，本类的方法优先级会比父类的方法高</p><h2 id="继承（6）"><a href="#继承（6）" class="headerlink" title="继承（6）"></a>继承（6）</h2><ul><li>单类继承原则：每个类都只能继承一个类</li><li>如果不写extends，java类默认继承java.lang.Object类</li><li>class Human extends java.lang.Object</li><li>java所有类从java.lang.Object开始，构建出一个类型继承树</li><li>Object类里面默认有clone，equals，finalize，getClass，hashCode，toString等方法</li><li>若一个方法在当前类中没有定义，那这个方法就来自它的父类</li></ul><h2 id="继承和构造函数"><a href="#继承和构造函数" class="headerlink" title="继承和构造函数"></a>继承和构造函数</h2><ul><li><p>每个java类都必须有构造函数</p></li><li><p>如果没有显式定义构造函数，java编译器自动产生一个空的无形参构造函数</p></li><li><p>每个子类的构造函数的第一句话，都默认调用父类的无参数构造函数super（）,除非子类的构造函数第一句话是super，而且super语句必须放在第一条，不会出现连续两条super语句</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>子类继承父类所有的东西（但不能直接访问private成员）</p><ul><li><p>java所有类都继承自java.lang.Object类</p></li><li><p>java所有的类都是单根继承的</p></li><li><p>子类构造函数默认第一句话都会区调用父类的构造函数</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-1-1继承&quot;&gt;&lt;a href=&quot;#6-1-1继承&quot; class=&quot;headerlink&quot; title=&quot;6.1.1继承&quot;&gt;&lt;/a&gt;6.1.1继承&lt;/h1&gt;&lt;p&gt;先看一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java核心03-抽象类与接口</title>
    <link href="https://theme-next.js.org/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://theme-next.js.org/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-05-02T23:13:24.000Z</published>
    <updated>2021-07-15T15:09:25.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类:</p><ul><li><p>一个完整健康的类:所有的方法都有实现（方法体）</p></li><li><p>类可以没有方法，但有方法就得实现，这才是一个完整的类</p></li><li><p>如果一个类暂时有方法未实现，需要被定义为抽象类</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> area;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">calArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象类关键字abstract声明<ul><li>抽象类的组成，成员变量个数不限</li><li>具体方法，方法有实现，个数不限</li><li>抽象方法，加abstract关键字，个数不限</li></ul></li></ul><p>当图形未知时，无法给出calArea的具体实现，因此此方法定义为abstract</p><h2 id="抽象类2"><a href="#抽象类2" class="headerlink" title="抽象类2"></a>抽象类2</h2><ul><li><p>抽象类也是类，一个类继承于抽象类，就不能继承于其他的抽象类</p></li><li><p>子类可以继承于抽象类，但是一定要实现父类们所有abstract的方法。</p></li><li><p>如果不能完全实现，那么子类也必须被定义为抽象类</p></li><li><p>只有实现父类的所有抽象方法，才变成完整类，否则会报错</p></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>如果类的所有方法都没有实现，那么这个类就算是接口</p></li><li><p>类可以实现多个接口，</p><p>例子：类c继承于类a，同时也实现接口b，c中的f1方法只会在a或c中实现</p></li><li><p>接口是特殊的类</p></li></ul><h2 id="接口2"><a href="#接口2" class="headerlink" title="接口2"></a>接口2</h2><ul><li><p>接口可以继承多个接口，没有实现的方法将会叠加</p></li><li><p>类实现接口，就必须实现所有未实现的方法。如果没有全部实现，那么只能成为一个抽象类（见ex4）</p><p>.ex1</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat:I can eat&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat:I can move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animal接口中含有eat和move两个方法</p><p>.ex2</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口爬树</p><p>.ex3</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClimbTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陆地动物</p><p>.ex4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> abstact <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I can walk bt feet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends 必须写在implements前面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> <span class="keyword">implements</span> <span class="title">ClimbTree</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Rabbit:I can climb&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.our.println(<span class="string">&quot;Rabbit:I can eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以继承一个抽象类，同时实现一个接口</p><p>而一个接口可以继承多个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CatFamily</span> <span class="keyword">extends</span> <span class="title">Animal</span>,<span class="title">ClimbTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//eat()</span></span><br><span class="line">    <span class="comment">//move()</span></span><br><span class="line">    <span class="comment">//climb()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">CatFamily</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Tiger:I can eat&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Tiger:I can move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Tiger:I can climb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="抽象类和接口-1"><a href="#抽象类和接口-1" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点:"></a>相同点:</h4><p>两者都不能被实例化，不嫩new操作</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>抽象类abstract 接口interface</p><p>抽象类可以有部分方法实现，接口所有方法不能有实现，</p><p>一个类只能继承一个抽象类，实现多个接口</p><p>接口可以继承多个接口</p><p>抽象类有构造函数，接口没有构造函数</p><p>抽象类可以有main，也能运行，接口没有main函数</p><p>抽象类方法可以有private/protected，接口方法都是public</p><table><thead><tr><th align="center">特点\类型</th><th align="center">类</th><th align="center">抽象类</th><th align="center">接口</th></tr></thead><tbody><tr><td align="center">构造函数</td><td align="center">有</td><td align="center">无</td><td align="center">有</td></tr><tr><td align="center">加入main方法并运行</td><td align="center">可行</td><td align="center">可</td><td align="center">不能</td></tr><tr><td align="center">可以有private/protected</td><td align="center">是</td><td align="center">是</td><td align="center">不</td></tr><tr><td align="center">继承</td><td align="center">可以继承一个类</td><td align="center">可以继承一个类，只要不是密封类</td><td align="center">可以继承接口</td></tr><tr><td align="center">实现接口</td><td align="center">可以实现多个接口</td><td align="center">可以实现多个接口</td><td align="center">不能</td></tr><tr><td align="center">实现方法</td><td align="center">必须实现所有的方法</td><td align="center">可以有部分方法实现</td><td align="center">所有方法不能有实现</td></tr><tr><td align="center">实例化</td><td align="center">可以</td><td align="center">不可以</td><td align="center">不可以</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抽象类和接口&quot;&gt;&lt;a href=&quot;#抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;抽象类和接口&quot;&gt;&lt;/a&gt;抽象类和接口&lt;/h1&gt;&lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java核心01-信息隐藏</title>
    <link href="https://theme-next.js.org/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E5%8E%9F%E5%88%99%E5%92%8Cthis/"/>
    <id>https://theme-next.js.org/%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E5%8E%9F%E5%88%99%E5%92%8Cthis/</id>
    <published>2021-04-22T01:45:24.000Z</published>
    <updated>2021-07-15T13:41:28.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息隐藏原则和this"><a href="#信息隐藏原则和this" class="headerlink" title="信息隐藏原则和this"></a>信息隐藏原则和this</h1><h2 id="信息隐藏原则"><a href="#信息隐藏原则" class="headerlink" title="信息隐藏原则"></a>信息隐藏原则</h2><h3 id="面向对象有一个法则：信息隐藏"><a href="#面向对象有一个法则：信息隐藏" class="headerlink" title="面向对象有一个法则：信息隐藏"></a>面向对象有一个法则：信息隐藏</h3><ul><li>类的成员属性，是私有的private</li><li>类的方法是公有public的，通过方法修改成员属性的值</li></ul><p>eg. 信息隐藏：通过类的方法来间接访问类的属性，而不是直接访问类的属性</p><ul><li><p>类成员是私有的</p></li><li><p>get和set方法是公有的统称为getter setter</p></li><li><p>外界对类成员的操作只能通过get和set方法来操作</p></li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>this 负责指向本类中的成员变量</li><li>在构造函数里，形参的优先级更高</li></ul><p>~ example1:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoHiding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoHiding</span><span class="params">(<span class="keyword">int</span> id2)</span></span>&#123;</span><br><span class="line">        id=id2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id2)</span></span>&#123;</span><br><span class="line">        id=id2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~ example2:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoHiding</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InfoHiding</span><span class="params">(<span class="keyword">int</span> id2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>this 负责指向本类中的成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.add(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//调用本类的add方法，this可以忽略</span></span><br></pre></td></tr></table></figure></li><li><p>this可以代替本类的构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>不影响歧义的情况下，this可以省略，参见example1</p></li></ul><p>总结一下，</p><ul><li><p>this可以指向本类中的成员变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.x</span><br></pre></td></tr></table></figure></li><li><p>可以指向本类中的成员方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.x()</span><br></pre></td></tr></table></figure></li><li><p>可以当作构造函数使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>(x);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Above-all"><a href="#Above-all" class="headerlink" title="Above all"></a>Above all</h2><ul><li>信息隐藏原则<ul><li>保护属性信息</li><li>公开行为信息</li></ul></li><li>this负责指向本类中的成员</li><li>this可以代替本类中的构造函数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息隐藏原则和this&quot;&gt;&lt;a href=&quot;#信息隐藏原则和this&quot; class=&quot;headerlink&quot; title=&quot;信息隐藏原则和this&quot;&gt;&lt;/a&gt;信息隐藏原则和this&lt;/h1&gt;&lt;h2 id=&quot;信息隐藏原则&quot;&gt;&lt;a href=&quot;#信息隐藏原则&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习入门？</title>
    <link href="https://theme-next.js.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%C2%B7%E7%AE%97%E6%B3%95/"/>
    <id>https://theme-next.js.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%C2%B7%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-02T22:42:24.000Z</published>
    <updated>2021-07-15T13:42:38.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习·算法"><a href="#机器学习·算法" class="headerlink" title="机器学习·算法"></a>机器学习·算法</h1><ul><li>参数不一样也是不同的模型</li></ul><ol><li><p>确定模型，设计模型：选定问题适合xx 模型 （model 如决策树，）</p></li><li><p>好坏标准（损失函数，loss function 学习就是学参数）</p></li><li><p>优化方法（预测能不能考上研，用已经考过研的同学的数据来训练，输入：？，输出（考上，不能考上））</p><ul><li><p>测试样本</p></li><li><p>历史数据，训练样本</p></li><li><p>训练的时候，二分类问题（神经网络,在训练网络上的好坏)</p></li><li><p>一万个同学的结果label</p></li><li><p>模型的label和真实label越接近越好</p></li><li><p>预测类别 准确率</p></li><li><p>误差</p></li><li><p>梯度下降</p></li><li><p>导数</p></li><li><p>函数极值点</p></li><li><p>优化方法</p></li><li><p>确定模型参数很多种选法</p></li><li><p>不可能把所有参数选一</p></li></ul></li></ol><ul><li><p>回归问题  目标函数输出是数值，（预测明天pm2.5的值）</p></li><li><p>分类问题 (预测明天pm2.5达不达标)</p></li><li><p>时间序列问题：在一个序列上解决的</p></li><li><p>怎么确定训练数据</p><ul><li><p>拿到去年一年的数据</p></li><li><p>三天一组</p></li><li><p>构造训练数据</p></li><li><p>一个月的pm2.5值</p></li></ul></li><li><p>slide-window 滑动窗口法</p><ul><li>2号三号一个 四号一个</li></ul></li><li><p>二分类==》多分类</p></li><li><p>大于2就叫多分类</p></li><li><p>实验 二分类</p></li><li><p>垃圾邮件过滤</p><ul><li><p>正样本和负样本的数量是差别很大的</p></li><li><p>非均衡样本使得你模型的效果不太好</p><p>垃圾邮件过滤</p><p>写规则</p><p>赌博，黄色</p><p>一堆专利</p><p>不写规则，让程序理解语义</p></li></ul></li><li><p> 输出的</p></li></ul><ul><li>alphago 分类问题</li><li>alphago确定棋子下到棋盘的几个位置</li><li>最基本的是学习能力</li><li>强化学习，自己和自己下</li></ul><ul><li><p>无监督：学习 如考试题没给答案</p></li><li></li><li><p>有监督：有标签的，有训练样本</p></li><li><p>半监督：样本有一部分有标签，有一部分没有标签</p></li><li><p>for example recognizing cats and dogs</p></li><li><p>迁移学习 </p></li><li><p>完全</p></li><li><p>没有训练样本，无监督学习</p></li></ul><p>强化学习</p><ul><li>当话务员，不知道该说什么，客户说一个问题你回答，客户再说一个问题你还回答，知道这个是不对的，非常差的反馈知道自己是错的</li><li>客户反馈不行知道错的，客户反馈可以知道还行</li></ul><p>Alphago </p><p>监督学习 ：棋谱 样本</p><p>强化学习： 自己和自己下棋</p><p>AlphaZero</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习·算法&quot;&gt;&lt;a href=&quot;#机器学习·算法&quot; class=&quot;headerlink&quot; title=&quot;机器学习·算法&quot;&gt;&lt;/a&gt;机器学习·算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;参数不一样也是不同的模型&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确定模型，设计模</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>byylswpu1</title>
    <link href="https://theme-next.js.org/byylswpu1/"/>
    <id>https://theme-next.js.org/byylswpu1/</id>
    <published>2021-01-02T21:45:24.000Z</published>
    <updated>2021-01-02T14:40:01.613Z</updated>
    
    <content type="html"><![CDATA[<p>二、实验内容<br>1、词法分析器设计<br>（1）单词的数据结构；<br>（2）记号类别编码；<br>（3）词法正规式；<br>（4）识别单词的状态转换图。<br>2、词法分析器实现<br>（1）实现辅助例程；<br>（2）实现独立的记号获取函数GetToken；<br>（3）构造测试文件，调试词法分析器（基本要求：能通过命令行界面输出分析结果）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">namespace scanner</span><br><span class="line">&#123;</span><br><span class="line">    //记号类别号</span><br><span class="line">    enum Token_Type</span><br><span class="line">    &#123;</span><br><span class="line">        ORIGIN, SCALE, ROT, IS, TO, //语言保留字(一字一类别)</span><br><span class="line">        STEP, DRAW, FOR, FROM,      //语言保留字</span><br><span class="line">        T,                          //语言中唯一的变量</span><br><span class="line">        ID,                         //标识符(若把关键字、变量都看成一种单词，可以使用本类别)</span><br><span class="line"></span><br><span class="line">        SEMICO, L_BRACKET, R_BRACKET, COMMA, //分隔符(分号、左括号、右括号、逗号)</span><br><span class="line">        PLUS, MINUS, MUL, DIV, POWER,        //运算符(加、减、乘、除、乘方)</span><br><span class="line"></span><br><span class="line">        FUNC,                                //(语言提供的标准数学)函数</span><br><span class="line"></span><br><span class="line">        CONST_ID,                           //数值常量</span><br><span class="line">        ERRTOKEN,                           //错误单词</span><br><span class="line">        NONTOKEN//专用记号(单词序列结束)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //记号数据类型</span><br><span class="line">    delegate double MathFunc(double d);//单参数的函数委托类型 delegate：代表</span><br><span class="line">    struct Token</span><br><span class="line">    &#123;</span><br><span class="line">        public Token_Type type; //类别号</span><br><span class="line">        public string lexeme;//标识符的字符串</span><br><span class="line">        public double value;//数值常数的值</span><br><span class="line">        public MathFunc func;             //函数委托</span><br><span class="line"></span><br><span class="line">        public Token(Token_Type type = Token_Type.NONTOKEN, string lexeme = &quot;&quot;, double value = 0, MathFunc func = null)</span><br><span class="line">        &#123;</span><br><span class="line">            this.type = type;</span><br><span class="line">            this.lexeme = lexeme;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.func = func;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        // 预定义单词表</span><br><span class="line">        static Token[] TokenTab = &#123;</span><br><span class="line">            //符号常数</span><br><span class="line">            new Token(Token_Type.CONST_ID,  &quot;PI&quot;,       3.1415926,  null),</span><br><span class="line">            new Token(Token_Type.CONST_ID,  &quot;E&quot;,        2.71828,    null),</span><br><span class="line">            //变量(惟一的)</span><br><span class="line">            new Token(Token_Type.T,         &quot;T&quot;,        0.0,        null),</span><br><span class="line">            //数学函数</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;SIN&quot;,      0.0,        Math.Sin),</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;COS&quot;,      0.0,        Math.Cos),</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;TAN&quot;,      0.0,        Math.Tan),</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;LN&quot;,       0.0,        Math.Log),</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;EXP&quot;,      0.0,        Math.Exp),</span><br><span class="line">            new Token(Token_Type.FUNC,      &quot;SQRT&quot;,     0.0,        Math.Sqrt),</span><br><span class="line">            //语句关键字</span><br><span class="line">            new Token(Token_Type.ORIGIN,    &quot;ORIGIN&quot;,   0.0,        null),</span><br><span class="line">            new Token(Token_Type.SCALE,     &quot;SCALE&quot;,    0.0,        null),</span><br><span class="line">            new Token(Token_Type.ROT,       &quot;ROT&quot;,      0.0,        null),</span><br><span class="line">            new Token(Token_Type.IS,        &quot;IS&quot;,       0.0,        null),</span><br><span class="line">            new Token(Token_Type.FOR,       &quot;FOR&quot;,      0.0,        null),</span><br><span class="line">            new Token(Token_Type.FROM,      &quot;FROM&quot;,     0.0,        null),</span><br><span class="line">            new Token(Token_Type.TO,        &quot;TO&quot;,       0.0,        null),</span><br><span class="line">            new Token(Token_Type.STEP,      &quot;STEP&quot;,     0.0,        null),</span><br><span class="line">            new Token(Token_Type.DRAW,      &quot;DRAW&quot;,     0.0,        null)</span><br><span class="line">        &#125;;</span><br><span class="line">        static Token ErrorToken = new Token(Token_Type.ERRTOKEN, &quot;error token&quot;, -1, null);</span><br><span class="line"></span><br><span class="line">        //c# 无 ungetc 函数（将一个字符退回输入流），所以用如下代码模拟</span><br><span class="line">        static char lastCh;</span><br><span class="line">        static bool ungetFlag = false;</span><br><span class="line">        //读取一个字符</span><br><span class="line">        static char getChar(StreamReader sr)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!ungetFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                lastCh = (char)sr.Read();</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                ungetFlag = false;</span><br><span class="line"></span><br><span class="line">            return lastCh;</span><br><span class="line">        &#125;</span><br><span class="line">        //退回一个字符</span><br><span class="line">        static void ungetChar(StreamReader sr)</span><br><span class="line">        &#123;</span><br><span class="line">            ungetFlag = true;</span><br><span class="line">        &#125;</span><br><span class="line">        //c 语言的 ungetc 函数，在 c# 中的模拟</span><br><span class="line"></span><br><span class="line">        //判断标识符是否语言的预定义单词</span><br><span class="line">        static Token IsKeyWords(string id)</span><br><span class="line">        &#123;</span><br><span class="line">            int i;</span><br><span class="line">            Token token = new Token();</span><br><span class="line"></span><br><span class="line">            for (i = 0; i &lt; TokenTab.Length; i++) if (string.Equals(TokenTab[i].lexeme, id)) break;</span><br><span class="line"></span><br><span class="line">            if (i &lt; TokenTab.Length)</span><br><span class="line">                token = TokenTab[i];</span><br><span class="line">            else</span><br><span class="line">                token = ErrorToken;</span><br><span class="line"></span><br><span class="line">            return token;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //显示单词</span><br><span class="line">        static void writeToken(Token token)</span><br><span class="line">        &#123;</span><br><span class="line">            if (token.type == Token_Type.FUNC)</span><br><span class="line">                Console.WriteLine(&quot;&#123;0,-15&#125;&#123;1, -15&#125;&#123;2, -15&#125;&#123;3, -20&#125;&quot;, (int)token.type, token.lexeme, token.value, (string)token.func.Method.Name);</span><br><span class="line">            else</span><br><span class="line">                Console.WriteLine(&quot;&#123;0,-15&#125;&#123;1, -15&#125;&#123;2, -15&#125;&#123;3, -20&#125;&quot;, (int)token.type, token.lexeme, token.value, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void getToken(StreamReader sr)</span><br><span class="line">        &#123;</span><br><span class="line">            //从源代码逐个读取字符</span><br><span class="line">            Token token;</span><br><span class="line">            char c, preCh;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                c = getChar(sr);</span><br><span class="line"></span><br><span class="line">                if (c == &#x27;-&#x27; || c == &#x27;/&#x27;)</span><br><span class="line">                &#123;//如果是注释</span><br><span class="line">                    preCh = c;</span><br><span class="line">                    c = getChar(sr);//读取新字符</span><br><span class="line">                    if (c == preCh)</span><br><span class="line">                    &#123; //判断注释符引导字符</span><br><span class="line">                        //去掉注释符引导字符</span><br><span class="line">                        while (c != &#x27;\n&#x27; &amp;&amp; !sr.EndOfStream)</span><br><span class="line">                        &#123;</span><br><span class="line">                            c = getChar(sr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        ungetChar(sr);</span><br><span class="line">                        c = preCh;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == &#x27;\t&#x27; || c == &#x27;\n&#x27; || c == &#x27;\r&#x27; || c == &#x27; &#x27;)</span><br><span class="line">                &#123;//过滤空白</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (char.IsLetter(c))</span><br><span class="line">                &#123; //读到的是字母</span><br><span class="line">                    string buf = &quot;&quot;;//临时缓冲buf</span><br><span class="line">                    buf += char.ToUpper(c);</span><br><span class="line">                    //遍历后续字符</span><br><span class="line">                    for (; ; )</span><br><span class="line">                    &#123;</span><br><span class="line">                        c = getChar(sr);</span><br><span class="line">                        if (char.IsLetterOrDigit(c))</span><br><span class="line">                        &#123; //如果仍是字母/数字</span><br><span class="line">                            buf += char.ToUpper(c);</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123; break; &#125;//读完</span><br><span class="line">                    &#125;</span><br><span class="line">                    ungetChar(sr);</span><br><span class="line"></span><br><span class="line">                    token = IsKeyWords(buf);</span><br><span class="line">                &#125;</span><br><span class="line">               else if (c == &#x27;(&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.L_BRACKET, &quot;(&quot;);</span><br><span class="line">                else if (c == &#x27;)&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.R_BRACKET, &quot;)&quot;);</span><br><span class="line">                else if (c == &#x27;-&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.MINUS, &quot;-&quot;);</span><br><span class="line">                else if (c == &#x27;;&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.SEMICO, &quot;;&quot;);</span><br><span class="line">                else if (c == &#x27;,&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.COMMA, &quot;,&quot;);</span><br><span class="line">                else if (c == &#x27;+&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.PLUS, &quot;+&quot;);</span><br><span class="line">                else if (c == &#x27;/&#x27;)</span><br><span class="line">                    token = new Token(Token_Type.DIV, &quot;/&quot;);</span><br><span class="line">                else if (c == &#x27;*&#x27;)</span><br><span class="line">                &#123;//乘号会有*和乘方**</span><br><span class="line">                    preCh = c;</span><br><span class="line">                    c = getChar(sr);//读取新字符</span><br><span class="line">                    if (c == preCh)</span><br><span class="line">                    &#123;</span><br><span class="line">                        token = new Token(Token_Type.POWER, &quot;**&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;//否则退回一个字符</span><br><span class="line">                        ungetChar(sr);</span><br><span class="line">                        token = new Token(Token_Type.MUL, &quot;*&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (char.IsDigit(c))</span><br><span class="line">                &#123;</span><br><span class="line">                    string buf = &quot;&quot;;</span><br><span class="line">                    buf += c;</span><br><span class="line"></span><br><span class="line">                    for (; ; )</span><br><span class="line">                    &#123;</span><br><span class="line">                        c = getChar(sr);</span><br><span class="line">                        if (char.IsDigit(c) || c == &#x27;.&#x27;)</span><br><span class="line">                        &#123; //如果仍是数字或小数点</span><br><span class="line">                            buf += c;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123; break; &#125;//读完</span><br><span class="line">                    &#125;</span><br><span class="line">                    ungetChar(sr);</span><br><span class="line"></span><br><span class="line">                    token = new Token(Token_Type.CONST_ID, &quot;&quot;, Convert.ToDouble(buf));</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    token = ErrorToken;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (sr.EndOfStream)</span><br><span class="line">                &#123; //判断文件读取结束</span><br><span class="line">                    token = new Token(Token_Type.NONTOKEN);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                writeToken(token);//输出单词</span><br><span class="line">            &#125;</span><br><span class="line">            writeToken(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0,-11&#125;&#123;1, -12&#125;&#123;2, -12&#125;&#123;3, -20&#125;&quot;, &quot;记号类别&quot;, &quot;字符串&quot;, &quot;常数值&quot;, &quot;函数指针&quot;);</span><br><span class="line">            Console.WriteLine(&quot;-------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">            //打开源代码文件</span><br><span class="line">            StreamReader sr;</span><br><span class="line">            if (args.Length == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                sr = File.OpenText(&quot;p89-8-10.draw&quot;);//文件在项目的子目录 bin\debug 下</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sr = File.OpenText(args[0].ToString());//允许通过命令行参数，给出源代码文件名</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            getToken(sr);</span><br><span class="line">            sr.Close();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二、实验内容&lt;br&gt;1、词法分析器设计&lt;br&gt;（1）单词的数据结构；&lt;br&gt;（2）记号类别编码；&lt;br&gt;（3）词法正规式；&lt;br&gt;（4）识别单词的状态转换图。&lt;br&gt;2、词法分析器实现&lt;br&gt;（1）实现辅助例程；&lt;br&gt;（2）实现独立的记号获取函数GetToken；&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
